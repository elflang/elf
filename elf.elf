;; -*- mode: lisp -*-

(var setup ()

  ;; Usually, macros are like variables: if a macro is defined within
  ;; a function, then it's local to that function.  In this case,
  ;; however, we want all macros defined within SETUP to be global.  We
  ;; accomplish this by replacing the local environment frame with the
  ;; global environment frame at compile time.

  (%compile-time
    (assign environment*.1 environment*.0))

  (mac quote (form)
    (quoted form))

  (mac quasiquote (form)
    (quasiexpand form 1))

  (mac at (l i)
    (if (and (is target* 'lua) (number? i))
        (++ i)
        (is target* 'lua)
        (assign i `(+ ,i 1)))
    `(get ,l ,i))

  (mac wipe (place)
    (if (is target* 'lua)
        `(assign ,place nil)
      `(%delete ,place)))

  (mac list body
    (w/uniq x
      (let (l () forms ())
        (each (k v) body
          (if (number? k)
              (assign (get l k) v)
            (add forms `(assign (get ,x ',k) ,v))))
        (if (some? forms)
            `(let ,x (%array ,@l) ,@forms ,x)
          `(%array ,@l)))))

  (mac xform (l body)
    `(map [do ,body] ,l))

  (mac if branches
    (hd (expand-if branches)))

  (mac case (x rest: clauses)
    (w/uniq e
      (let bs (map (fn ((a b))
                     (if (nil? b)
                         (list a)
                       `((is ,a ,e) ,b)))
                   (pair clauses))
        `(let (,e ,x) (if ,@(apply join bs))))))

  (mac when (cond rest: body)
    `(if ,cond (do ,@body)))

  (mac unless (cond rest: body)
    `(if (not ,cond) (do ,@body)))

  (mac assert (cond)
    `(unless ,cond
       ,(let x (cat "assert: " (str cond))
         `(error ',x))))

  (mac obj body
    `(%object ,@(mapo [do _] body)))

  (mac let (bs rest: body)
    (if (atom? bs) `(let (,bs ,(hd body)) ,@(tl body))
        (none? bs) `(do ,@body)
      (let ((lh rh rest: bs2) bs
            (id val rest: bs1) (bind lh rh))
        (let renames ()
          (if (or (bound? id) (toplevel?))
              (let id1 (uniq id)
                (assign renames (list id id1))
                (assign id id1))
            (setenv id :variable))
          `(do (%local ,id ,val)
               (w/sym ,renames
                 (let ,(join bs1 bs2) ,@body)))))))

  (mac = l
    (case (# l)
      0 nil
      1 `(= ,@l nil)
      2 (let ((lh rh) l)
          (if (or (atom? lh) (case (hd lh) 'at true 'get true))
              `(assign ,lh ,rh)
              (let (vars ()
                    forms (bind lh rh vars))
                `(do ,@(xform vars
                         `(var ,_))
                     ,@(map (fn ((id val)) `(= ,id ,val))
                            (pair forms))))))
      `(do ,@(xform (pair l)
               `(= ,@_)))))

  (mac with (x v rest: body)
    `(let (,x ,v) ,@body ,x))

  (mac whenlet (x v rest: body)
    (w/uniq y
      `(let ,y ,v
         (when ,y
           (let (,x ,y)
             ,@body)))))

  (mac mac (name args rest: body)
    (let form `(setenv ',name macro: (fn ,args ,@body))
      (eval form)
      form))

  (mac defspecial (name args rest: body)
    (let form `(setenv ',name special: (fn ,args ,@body) ,@(keys body))
      (eval form)
      form))

  (mac defsym (name expansion)
    (setenv name symbol: expansion)
    `(setenv ',name symbol: ',expansion))

  (mac var (name x rest: body)
    (setenv name :variable)
    (if (some? body)
        `(%local-function ,name ,@(bind* x body))
      `(%local ,name ,x)))

  (mac def (name x rest: body)
    (setenv name :toplevel :variable)
    (if (some? body)
        `(%global-function ,name ,@(bind* x body))
      `(= ,name ,x)))

  (mac w/frame body
    (w/uniq x
      `(do (add environment* (obj))
           (with ,x (do ,@body)
             (drop environment*)))))

  (mac w/bindings ((names) rest: body)
    (w/uniq x
     `(w/frame
        (each ,x ,names
          (setenv ,x :variable))
        ,@body)))

  (mac w/mac (name args definition rest: body)
    (w/frame
      (macroexpand `(mac ,name ,args ,definition))
      `(do ,@(macroexpand body))))

  (mac w/sym (expansions rest: body)
    (if (atom? expansions)
        `(w/sym (,expansions ,(hd body)) ,@(tl body))
      (w/frame
        (map (fn ((name exp))
               (macroexpand `(defsym ,name ,exp)))
             (pair expansions))
        `(do ,@(macroexpand body)))))

  (mac w/uniq (names rest: body)
    `(let ,(apply join
             (xform (listify names)
               `(,_ (uniq ',_))))
       ,@body))

  (mac fn (args rest: body)
    `(%function ,@(bind* args body)))

  (mac guard (expr)
    (if (is target* 'js)
        `([%try (list true ,expr)])
      (w/uniq (x msg trace)
        `(let (,x nil
               ,msg nil
               ,trace nil)
           (if (xpcall
                [= ,x ,expr]
                [do
                  (= ,msg (clip _ (+ (search _ ": ") 2)))
                  (= ,trace (debug.traceback))])
               (list true ,x)
             (list false ,msg ,trace))))))

  (mac each (x t rest: body)
    (w/uniq (l n i)
      (let ((k v) (if (atom? x) (list i x)
                    (if (> (# x) 1) x
                        (list i (hd x)))))
        `(let (,l ,t ,k nil)
           (%for ,l ,k
             (let (,v (get ,l ,k))
               ,@(if (is target* 'lua) body
                     `((let ,k (if (numeric? ,k)
                                   (parseInt ,k)
                                 ,k)
                         ,@body)))))))))

  (mac for (i rest: body)
    (let (from 0 to 0 increment 1)
      (if (atom? i)
          (= to (hd body)
             body (tl body))
        (= (i from to (o increment 1)) i))
      (assert (number? increment))
      (if (> increment 0)
        `(let (,i ,from)
           (while (< ,i ,to) ,@body (++ ,i ,increment)))
        `(let (,i (- ,to 1))
           (while (>= ,i ,from) ,@body (-- ,i ,(- increment)))))))

  (mac step (v t rest: body)
    (w/uniq (x n i)
      `(let (,x ,t ,n (# ,x))
         (for ,i ,n
           (let (,v (at ,x ,i))
             ,@body)))))

  (mac set-of xs
    (let l ()
      (each x xs
        (= (get l x) true))
      `(obj ,@l)))

  (mac language () `',target*)

  (mac target clauses
    (get clauses target*))

  (mac join! (a rest: bs)
    `(= ,a (join ,a ,@bs)))

  (mac cat! (a rest: bs)
    `(= ,a (cat ,a ,@bs)))

  (mac ++ (n by)
    `(= ,n (+ ,n ,(or by 1))))

  (mac -- (n by)
    `(= ,n (- ,n ,(or by 1))))

  (mac export names
    (if (is target* 'js)
        `(do ,@(xform names
                 `(= (get exports ',_) ,_)))
      (let x (obj)
        (each k names
          (= (get x k) k))
        `(return (obj ,@x)))))

  (mac undef? (var)
    (if (is target* 'js)
       `(is (typeof ,var) "undefined")
     `(is ,var nil)))

  (mac %js forms
    (when (is target* 'js)
      `(do ,@forms)))

  (mac %lua forms
    (when (is target* 'lua)
      `(do ,@forms)))

  (mac %compile-time forms
    (eval `(do ,@forms))
    nil)

  (mac once forms
    (w/uniq x
      `(when (undef? ,x)
         (= ,x true)
         ,@forms)))

  (mac elf ()
    `(require 'elf))

  (mac lib modules
    `(do ,@(xform modules `(def ,_ (require ',_)))))

  (mac use modules
    `(do ,@(xform modules `(var ,_ (require ',_)))))

  (mac nil? (x)
    `(target
       lua: (is ,x nil)
       js: ,(if (atom? x)
                `(or (is (typeof ,x) "undefined") (is ,x null))
              `(let (x ,x) (nil? x)))))

  (defspecial %len (x)
    (cat "#(" (compile x) ")"))

  (mac # (x)
    `(target
       lua: (%len ,x)
       js: (or (get ,x 'length) 0)))

  (mac none? (x) `(is (# ,x) 0))
  (mac some? (x) `(> (# ,x) 0))
  (mac one? (x) `(is (# ,x) 1))
  (mac two? (x) `(is (# ,x) 2))

  (mac hd (l) `(at ,l 0))
  (mac tl (l) `(cut ,l 1))

  ;; When a function and a macro share the same name, e.g. FOO, the
  ;; macro takes priority: (foo ...) will expand the macro.  To call
  ;; the function, write ((do foo) ...)

  (mac type (x)
    `(target
       lua: ((do type) ,x)
       js: (typeof ,x)))

  (mac string? (x) `(is (type ,x) 'string))
  (mac number? (x) `(is (type ,x) 'number))
  (mac bool? (x) `(is (type ,x) 'boolean))
  (mac fn? (x) `(is (type ,x) 'function))
  (mac list? (x) `(is (type ,x) (target js: 'object lua: 'table)))
  (mac atom? (x) `(~list? ,x))

  (mac listify (x)
    (assert (atom? x))
    `(if (list? ,x) ,x (list ,x)))

  nil)

(once
  (def environment* (list (obj)))
  (def target* (language)))

(def nan (/ 0 0))
(def inf (/ 1 0))

(def nan? (n)
  (~is n n))

(def inf? (n)
  (or (is n inf) (is n -inf)))

(def clip (s from upto)
  (%js (s.substring from upto))
  (%lua (string.sub s (+ from 1) upto)))

(def cut (x (o from 0) (o upto (# x)))
  (with l ()
    (var j 0)
    (var to (min (# x) upto))
    (for (i (max 0 from) to)
      (= (at l j) (at x i))
      (++ j))
    (each (k v) x
      (unless (number? k)
        (= (get l k) v)))))

(def keys (x)
  (with t ()
    (each (k v) x
      (unless (number? k)
        (= (get t k) v)))))

(def edge (x)
  (- (# x) 1))

(def inner (x)
  (clip x 1 (edge x)))

(def char (s n)
  (%js (s.charAt n))
  (%lua (clip s n (+ n 1))))

(def code (s n)
  (%js (s.charCodeAt n))
  (%lua (string.byte s (if n (+ n 1)))))

(def chr (c)
  (%js (String.fromCharCode c))
  (%lua (string.char c)))

(def string-literal? (x)
  (and (string? x) (is (char x 0) "\"")))

(def id-literal? (x)
  (and (string? x) (is (char x 0) "|")))

(def add (l x)
  (%js (do (l.push x) nil))
  (%lua (table.insert l x)))

(def drop (l)
  (%js (l.pop))
  (%lua (table.remove l)))

(def last (l)
  (at l (edge l)))

(def almost (l)
  (cut l 0 (edge l)))

(def rev (l)
  (with l1 (keys l)
    (for (i 0 (# l) -1)
      (add l1 (at l i)))))

(def reduce (f x)
  (if (none? x) nil
      (one? x) (hd x)
    (f (hd x) (reduce f (tl x)))))

(def join ls
  (if (two? ls)
      (let ((a b) ls)
        (if (and a b)
            (let (c () o (# a))
              (each (k v) a
                (= (get c k) v))
              (each (k v) b
                (when (number? k)
                  (++ k o))
                (= (get c k) v))
              c)
          (or a b ())))
    (or (reduce join ls) ())))

(def find (f t)
  (each x t
    (let y (f x)
      (if y (return y)))))

(def ontree (f t :skip)
  (unless (and skip (skip t))
    (let y (f t)
      (if y (return y)))
    (unless (atom? t)
      (each x t
        (let y (ontree f x skip: skip)
          (if y (return y)))))))

(def hd-is? (l val)
  (and (~atom? l) (is (hd l) val)))

(def first (f l)
  (step x l
    (let y (f x)
      (if y (return y)))))

(def in? (x t)
  (find [is x _] t))

(def pair (l)
  (with l1 ()
    (for i (# l)
      (add l1 (list (at l i) (at l (+ i 1))))
      (++ i))))

(def sort (l f)
  (%lua (do (table.sort l f) l))
  (%js (l.sort (when f [if (f _0 _1) -1 1]))))

(def map (f x)
  (with t ()
    (step v x
      (let y (f v)
        (unless (nil? y)
          (add t y))))
    (each (k v) x
      (unless (number? k)
        (let y (f v)
          (unless (nil? y)
            (= (get t k) y)))))))

(def keep (f x)
  (map [when (f _) _] x))

(def keys? (t)
  (each (k v) t
    (unless (number? k)
      (return true)))
  false)

(def empty? (t)
  (each x t
    (return false))
  true)

(def stash (args)
  (when (keys? args)
    (let p ()
      (each (k v) args
        (unless (number? k)
          (= (get p k) v)))
      (= p._stash true)
      (add args p)))
  args)

(def unstash (args)
  (if (none? args) ()
    (let l (last args)
      (if (and (~atom? l) l._stash)
          (with args1 (almost args)
            (each (k v) l
              (unless (is k '_stash)
                (= (get args1 k) v))))
        args))))

(def search (s pattern start)
  (%js
    (let i (s.indexOf pattern start))
    (if (>= i 0) i))
  (%lua
    (let (start (if start (+ start 1))
          i (string.find s pattern start true))
      (and i (- i 1)))))

(def split (s sep)
  (if (or (is s "") (is sep "")) ()
    (with l ()
      (let n (# sep)
        (while true
          (let i (search s sep)
            (if (nil? i) (break)
              (do (add l (clip s 0 i))
                  (= s (clip s (+ i n)))))))
        (add l s)))))

(def cat xs (or (reduce [cat _0 _1] xs) ""))
(def + xs (or (reduce [+ _0 _1] xs) 0))
(def - xs (or (reduce [- _1 _0] (rev xs)) 0))
(def * xs (or (reduce [* _0 _1] xs) 1))
(def / xs (or (reduce [/ _1 _0] (rev xs)) 1))
(def % xs (or (reduce [% _1 _0] (rev xs)) 1))

(def > (a b) (> a b))
(def < (a b) (< a b))
(def is (a b) (is a b))
(def >= (a b) (>= a b))
(def <= (a b) (<= a b))

(def number (s)
  (%lua (tonumber s))
  (%js (let n (parseFloat s)
         (unless (isNaN n) n))))

(def number-code? (n)
  (and (> n 47) (< n 58)))

(def numeric? (s)
  (let n (# s)
    (for i n
      (unless (number-code? (code s i))
        (return false))))
  true)

(%js (var tostring (x) (x.toString)))

(def escape (s)
  (let s1 "\""
    (for i (# s)
      (let (c (char s i)
            c1 (if (is c "\n") "\\n"
                   (is c "\"") "\\\""
                   (is c "\\") "\\\\"
                 c))
        (cat! s1 c1)))
    (cat s1 "\"")))

(def str (x depth (o stack ()))
  (if (in? x stack) "circular"
      (nil? x) "nil"
      (nan? x) "nan"
      (is x inf) "inf"
      (is x -inf) "-inf"
      (bool? x) (if x "true" "false")
      (string? x) (escape x)
      (fn? x) "fn"
      (~atom? x)
      (let (s "(" sp ""
            xs () ks ()
            d (+ (or depth 0) 1))
        (add stack x)
        (each (k v) x
          (if (number? k)
              (= (get xs k) (str v d stack))
            (do (add ks (cat k ":"))
                (add ks (str v d stack)))))
        (drop stack)
        (each v (join xs ks)
          (cat! s sp v)
          (= sp " "))
        (cat s  ")"))
    (escape (tostring x))))

(%lua (var values (or unpack table.unpack)))

(def apply (f args)
  (let args (stash args)
    (%js (f.apply f args))
    (%lua (f (values args)))))

(def toplevel? ()
  (one? environment*))

(def setenv (k rest: keys)
  (when (string? k)
    (let (frame (if keys.toplevel
                    (hd environment*)
                  (last environment*))
          entry (or (get frame k) (obj)))
      (each (k v) keys
        (= (get entry k) v))
      (= (get frame k) entry))))

(%js (def print (x) (console.log x)))

(%js (var math Math))

(def abs math.abs)
(def acos math.acos)
(def asin math.asin)
(def atan math.atan)
(def atan2 math.atan2)
(def ceil math.ceil)
(def cos math.cos)
(def floor math.floor)
(def log math.log)
(def log10 math.log10)
(def max math.max)
(def min math.min)
(def pow math.pow)
(def random math.random)
(def sin math.sin)
(def sinh math.sinh)
(def sqrt math.sqrt)
(def tan math.tan)
(def tanh math.tanh)

(setup)

