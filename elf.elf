;; -*- mode: lisp -*-

;; This file defines a small runtime that implements the Elf language.
;;
;; Whenever this file is modified and recompiled, the compiler --
;; which is using an older version of the Elf runtime when it begins
;; compiling this file -- steps through each expression, generates
;; equivalent JS or Lua code, then overwrites the old .js and .lua
;; files with the new code.
;;
;; This enables us to implement the Elf language in Elf.  No external
;; Javascript or Lua code files are used.

(var setup ()

  ;; We begin by defining the core language constructs as macros.
  ;; 
  ;; Each `mac` expression compiles to a call to `setenv`,
  ;; but `setenv` hasn't been defined yet.  Therefore we put them
  ;; inside this wrapper function, which is called at the bottom of
  ;; the file.
  ;;
  ;; Note that whenever the compiler encounters a `(mac ...)`
  ;; form, the compiler passes it to `eval` immediately.  In other
  ;; words, it has an immediate effect on the compile-time
  ;; environment.  This enables us to start using each macro right
  ;; away, without even calling this wrapper function.
  ;;
  ;; In that case, why call this wrapper function at all?  Consider
  ;; the following Javascript:
  ;;
  ;;   require("elf.js");
  ;;
  ;; This doesn't recompile `elf.elf`, but still needs to load all
  ;; the macros defined in it.

  (mac quote (form)
    (quoted form))

  (mac quasiquote (form)
    (quasiexpand form 1))

  (mac at (l i)
    (if (and (is target 'lua) (number? i))
        (inc i)
        (is target 'lua)
        (assign i `(+ ,i 1)))
    `(get ,l ,i))

  (mac wipe (place)
    (if (is target 'lua)
        `(assign ,place nil)
      `(%delete ,place)))

  (mac list body
    (let-unique (x)
      (let (l () forms ())
        (each (k v) body
          (if (number? k)
              (assign (get l k) v)
            (add forms `(assign (get ,x ',k) ,v))))
        (if (some? forms)
            `(let ,x (%array ,@l) ,@forms ,x)
          `(%array ,@l)))))

  (mac if branches
    (hd (expand-if branches)))

  (mac case (x rest: clauses)
    (let-unique (e)
      (let bs (map (fn ((a b))
                     (if (nil? b)
                         (list a)
                       `((is ,a ,e) ,b)))
                   (pair clauses))
        `(let (,e ,x) (if ,@(apply join bs))))))

  (mac when (cond rest: body)
    `(if ,cond (do ,@body)))

  (mac unless (cond rest: body)
    `(if (not ,cond) (do ,@body)))

  (mac obj body
    `(%object ,@(mapo [do _] body)))

  (mac let (bs rest: body)
    (if (atom? bs) `(let (,bs ,(hd body)) ,@(tl body))
        (none? bs) `(do ,@body)
      (let ((lh rh rest: bs2) bs
            (id val rest: bs1) (bind lh rh))
        (let renames ()
          (if (or (bound? id) (toplevel?))
              (let id1 (unique id)
                (assign renames (list id id1))
                (assign id id1))
            (setenv id :variable))
          `(do (%local ,id ,val)
               (let-symbol ,renames
                 (let ,(join bs1 bs2) ,@body)))))))

  (mac = l
    (case (# l)
      0 nil
      1 `(= ,@l nil)
      2 (let ((lh rh) l)
          (if (or (atom? lh) (case (hd lh) 'at true 'get true))
              `(assign ,lh ,rh)
              (let (vars ()
                    forms (bind lh rh vars))
                `(do ,@(map [do `(var ,_)]
                            vars)
                     ,@(map (fn ((id val)) `(= ,id ,val))
                            (pair forms))))))
      `(do ,@(map [do `(= ,@_)]
                  (pair l)))))

  (mac with (x v rest: body)
    `(let (,x ,v) ,@body ,x))

  (mac let-when (x v rest: body)
    (let-unique (y)
      `(let ,y ,v
         (when ,y
           (let (,x ,y)
             ,@body)))))

  (mac mac (name args rest: body)
    (let form `(setenv ',name macro: (fn ,args ,@body))
      (eval form)
      form))

  (mac defspecial (name args rest: body)
    (let form `(setenv ',name special: (fn ,args ,@body) ,@(keys body))
      (eval form)
      form))

  (mac defsym (name expansion)
    (setenv name symbol: expansion)
    `(setenv ',name symbol: ',expansion))

  (mac var (name x rest: body)
    (setenv name :variable)
    (if (some? body)
        `(%local-function ,name ,@(bind* x body))
      `(%local ,name ,x)))

  (mac def (name x rest: body)
    (setenv name :toplevel :variable)
    (if (some? body)
        `(%global-function ,name ,@(bind* x body))
      `(= ,name ,x)))

  (mac with-frame body
    (let-unique (x)
      `(do (add environment (obj))
           (with ,x (do ,@body)
             (drop environment)))))

  (mac with-bindings ((names) rest: body)
    (let-unique (x)
     `(with-frame
        (each ,x ,names
          (setenv ,x :variable))
        ,@body)))

  (mac let-macro (definitions rest: body)
    (with-frame
      (map [macroexpand `(mac ,@_)]
           definitions)
      `(do ,@(macroexpand body))))

  (mac let-symbol (expansions rest: body)
    (with-frame
      (map (fn ((name exp))
             (macroexpand `(defsym ,name ,exp)))
           (pair expansions))
      `(do ,@(macroexpand body))))

  (mac let-unique (names rest: body)
    (let bs (map [list _ `(unique ',_)]
                 names)
      `(let ,(apply join bs)
         ,@body)))

  (mac fn (args rest: body)
    `(%function ,@(bind* args body)))

  (mac guard (expr)
    (if (is target 'js)
        `([%try (list true ,expr)])
      (let-unique (x msg trace)
        `(let (,x nil
               ,msg nil
               ,trace nil)
           (if (xpcall
                [= ,x ,expr]
                [do
                  (= ,msg (clip _ (+ (search _ ": ") 2)))
                  (= ,trace (debug.traceback))])
               (list true ,x)
             (list false ,msg ,trace))))))

  (mac each (x t rest: body)
    (let-unique (o n i)
      (let ((k v) (if (atom? x) (list i x)
                    (if (> (# x) 1) x
                        (list i (hd x)))))
        `(let (,o ,t ,k nil)
           (%for ,o ,k
             (let (,v (get ,o ,k))
               ,@(if (is target 'lua) body
                     `((let ,k (if (numeric? ,k)
                                   (parseInt ,k)
                                 ,k)
                         ,@body)))))))))

  (mac for-1 ((i from to (o by 1)) rest: body)
    `(let ,i ,from
       (while (< ,i ,to)
         ,@body
         (inc ,i ,by))))

  (mac for (i rest: body)
    (if (atom? i)
        `(for-1 (,i 0 ,(hd body)) ,@(tl body))
      `(for-1 ,i ,@body)))

  (mac step (v t rest: body)
    (let-unique (x n i)
      `(let (,x ,t ,n (# ,x))
         (for ,i ,n
           (let (,v (at ,x ,i))
             ,@body)))))

  (mac set-of xs
    (let l ()
      (each x xs
        (= (get l x) true))
      `(obj ,@l)))

  (mac language () `',target)

  (mac target clauses
    (get clauses target))

  (mac join! (a rest: bs)
    `(= ,a (join ,a ,@bs)))

  (mac cat! (a rest: bs)
    `(= ,a (cat ,a ,@bs)))

  (mac inc (n by)
    `(= ,n (+ ,n ,(or by 1))))

  (mac dec (n by)
    `(= ,n (- ,n ,(or by 1))))

  (mac with-indent (form)
    (let-unique (x)
      `(do (inc indent-level)
           (with ,x ,form
             (dec indent-level)))))

  (mac export names
    (if (is target 'js)
        `(do ,@(map [do `(= (get exports ',_) ,_)]
                    names))
      (let x (obj)
        (each k names
          (= (get x k) k))
        `(return (obj ,@x)))))

  (mac undef? (var)
    (if (is target 'js)
       `(is (typeof ,var) "undefined")
     `(is ,var nil)))

  (mac %js forms
    (when (is target 'js)
      `(do ,@forms)))

  (mac %lua forms
    (when (is target 'lua)
      `(do ,@forms)))

  (mac %compiling forms
    (eval `(do ,@forms))
    nil)

  (mac once forms
    (let-unique (x)
      `(when (undef? ,x)
         (= ,x true)
         ,@forms)))

  (mac assert (cond)
    `(unless ,cond
       (error 'assert)))

  (mac elf ()
    `(require 'elf))

  (mac lib modules
    `(do ,@(map [do `(def ,_ (require ',_))] modules)))

  (mac use modules
    `(do ,@(map [do `(var ,_ (require ',_))] modules)))

  nil

  ;; Since we're within a wrapper function, the above definitions were
  ;; attached to a local compilation frame.  Normally this frame would
  ;; be dropped at the end of this wrapper function's scope.  Since we
  ;; want the definitions to persist, we insert them into the toplevel
  ;; frame.
  (%compiling
    (join! (at environment 0) (at environment 1))))

(once
  (def environment (list (obj)))
  (def target (language)))

(def nil? (x)
  (%js (or (is x nil) (is x null)))
  (%lua (is x nil)))

(def is? (x) (~nil? x))

(def # (x)
  (%js (or x.length 0))
  (%lua |#x|))

(def none? (x) (is (# x) 0))
(def some? (x) (> (# x) 0))
(def one? (x) (is (# x) 1))
(def two? (x) (is (# x) 2))

(def hd (l) (at l 0))

(%js (def type (x) (typeof x)))

(def string? (x) (is (type x) 'string))
(def number? (x) (is (type x) 'number))
(def boolean? (x) (is (type x) 'boolean))
(def function? (x) (is (type x) 'function))

(def atom? (x)
  (or (nil? x) (string? x) (number? x) (boolean? x)))

(def nan (/ 0 0))
(def inf (/ 1 0))

(def nan? (n)
  (~is n n))

(def inf? (n)
  (or (is n inf) (is n -inf)))

(def clip (s from upto)
  (%js (s.substring from upto))
  (%lua (string.sub s (+ from 1) upto)))

(def cut (x from upto)
  (with l ()
    (let (j 0
          i (if (or (nil? from) (< from 0)) 0 from)
          n (# x)
          upto (if (or (nil? upto) (> upto n)) n upto))
      (while (< i upto)
        (= (at l j) (at x i))
        (inc i)
        (inc j))
      (each (k v) x
        (unless (number? k)
          (= (get l k) v))))))

(def keys (x)
  (with t ()
    (each (k v) x
      (unless (number? k)
        (= (get t k) v)))))

(def edge (x)
  (- (# x) 1))

(def inner (x)
  (clip x 1 (edge x)))

(def tl (l) (cut l 1))

(def char (s n)
  (%js (s.charAt n))
  (%lua (clip s n (+ n 1))))

(def code (s n)
  (%js (s.charCodeAt n))
  (%lua (string.byte s (if n (+ n 1)))))

(def chr (c)
  (%js (String.fromCharCode c))
  (%lua (string.char c)))

(def string-literal? (x)
  (and (string? x) (is (char x 0) "\"")))

(def id-literal? (x)
  (and (string? x) (is (char x 0) "|")))

(def add (l x)
  (%js (do (l.push x) nil))
  (%lua (table.insert l x)))

(def drop (l)
  (%js (l.pop))
  (%lua (table.remove l)))

(def last (l)
  (at l (edge l)))

(def almost (l)
  (cut l 0 (edge l)))

(def reverse (l)
  (with l1 (keys l)
    (let i (edge l)
      (while (>= i 0)
        (add l1 (at l i))
        (dec i)))))

(def reduce (f x)
  (if (none? x) nil
      (one? x) (hd x)
    (f (hd x) (reduce f (tl x)))))

(def join ls
  (if (two? ls)
      (let ((a b) ls)
        (if (and a b)
            (let (c () o (# a))
              (each (k v) a
                (= (get c k) v))
              (each (k v) b
                (when (number? k)
                  (inc k o))
                (= (get c k) v))
              c)
          (or a b ())))
    (or (reduce join ls) ())))

(def find (f t)
  (each x t
    (let y (f x)
      (if y (return y)))))

(def first (f l)
  (step x l
    (let y (f x)
      (if y (return y)))))

(def in? (x t)
  (find [is x _] t))

(def pair (l)
  (with l1 ()
    (for i (# l)
      (add l1 (list (at l i) (at l (+ i 1))))
      (inc i))))

(def sort (l f)
  (%lua (do (table.sort l f) l))
  (%js (l.sort (when f [if (f _0 _1) -1 1]))))

(def map (f x)
  (with t ()
    (step v x
      (let y (f v)
        (if (is? y)
          (add t y))))
    (each (k v) x
      (unless (number? k)
        (let y (f v)
          (when (is? y)
            (= (get t k) y)))))))

(def cons (x y)
  `(,x ,@y))

(def treewise (f base tree)
  (if (atom? tree) (base tree)
      (none? tree) ()
    (f (treewise f base (hd tree))
       (treewise f base (tl tree)))))

(def keep (f x)
  (map [when (f _) _] x))

(def keys? (t)
  (each (k v) t
    (unless (number? k)
      (return true)))
  false)

(def empty? (t)
  (each x t
    (return false))
  true)

(def stash (args)
  (when (keys? args)
    (let p ()
      (each (k v) args
        (unless (number? k)
          (= (get p k) v)))
      (= p._stash true)
      (add args p)))
  args)

(def unstash (args)
  (if (none? args) ()
    (let l (last args)
      (if (and (~atom? l) (~function? l) l._stash)
          (with args1 (almost args)
            (each (k v) l
              (unless (is k '_stash)
                (= (get args1 k) v))))
        args))))

(def search (s pattern start)
  (%js
    (let i (s.indexOf pattern start))
    (if (>= i 0) i))
  (%lua
    (let (start (if start (+ start 1))
          i (string.find s pattern start true))
      (and i (- i 1)))))

(def split (s sep)
  (if (or (is s "") (is sep "")) ()
    (with l ()
      (let n (# sep)
        (while true
          (let i (search s sep)
            (if (nil? i) (break)
              (do (add l (clip s 0 i))
                  (= s (clip s (+ i n)))))))
        (add l s)))))

(def cat xs
  (or (reduce [cat _0 _1] xs) ""))

(def + xs
  (or (reduce [+ _0 _1] xs) 0))

(def - xs
  (or (reduce [- _1 _0] (reverse xs)) 0))

(def * xs
  (or (reduce [* _0 _1] xs) 1))

(def / xs
  (or (reduce [/ _1 _0] (reverse xs)) 1))

(def % xs
  (or (reduce [% _1 _0] (reverse xs)) 1))

(def > (a b) (> a b))
(def < (a b) (< a b))
(def = (a b) (is a b))
(def >= (a b) (>= a b))
(def <= (a b) (<= a b))

(def number (s)
  (%lua
    (tonumber s))
  (%js
    (let n (parseFloat s)
        (unless (isNaN n) n))))

(def number-code? (n)
  (and (> n 47) (< n 58)))

(def numeric? (s)
  (let n (# s)
    (for i n
      (unless (number-code? (code s i))
        (return false))))
  true)

(%js (var tostring (x) (x.toString)))

(def escape (s)
  (let s1 "\""
    (for i (# s)
      (let (c (char s i)
            c1 (if (is c "\n") "\\n"
                   (is c "\"") "\\\""
                   (is c "\\") "\\\\"
                 c))
        (cat! s1 c1)))
    (cat s1 "\"")))

(def str (x depth)
  (if (and depth (> depth 40)) "circular"
      (nil? x) "nil"
      (nan? x) "nan"
      (is x inf) "inf"
      (is x -inf) "-inf"
      (boolean? x) (if x "true" "false")
      (string? x) (escape x)
      (atom? x) (tostring x)
      (function? x) "fn"
    (let (s "(" sp ""
          xs () ks ()
          d (+ (or depth 0) 1))
      (each (k v) x
        (if (number? k)
            (= (get xs k) (str v d))
          (do (add ks (cat k ":"))
              (add ks (str v d)))))
      (each v (join xs ks)
        (cat! s sp v)
        (= sp " "))
      (cat s  ")"))))

(%lua (var values (or unpack table.unpack)))

(def apply (f args)
  (let args (stash args)
    (%js (f.apply f args))
    (%lua (f (values args)))))

(def call (f) (f))

(def toplevel? ()
  (one? environment))

(def setenv (k rest: keys)
  (when (string? k)
    (let (frame (if keys.toplevel
                    (hd environment)
                  (last environment))
          entry (or (get frame k) (obj)))
      (each (k v) keys
        (= (get entry k) v))
      (= (get frame k) entry))))

(%js (def print (x) (console.log x)))

(%js (var math Math))

(def abs math.abs)
(def acos math.acos)
(def asin math.asin)
(def atan math.atan)
(def atan2 math.atan2)
(def ceil math.ceil)
(def cos math.cos)
(def floor math.floor)
(def log math.log)
(def log10 math.log10)
(def max math.max)
(def min math.min)
(def pow math.pow)
(def random math.random)
(def sin math.sin)
(def sinh math.sinh)
(def sqrt math.sqrt)
(def tan math.tan)
(def tanh math.tanh)

(setup)

