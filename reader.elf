;; -*- mode: lisp -*-

(mac defreader ((char s) rest: body)
  `(assign (get read-table ,char) (fn (,s) ,@body)))

(var delimiters (set-of "(" ")" ";" "\n"))
(var whitespace (set-of " " "\t" "\n"))

(var stream (str more)
  (obj pos: 0 string: str len: (# str) more: more))

(var peek-char (s)
  (let ((:pos :len :string) s)
    (when (< pos len)
      (char string pos))))

(var read-char (s)
  (let c (peek-char s)
    (if c (do (inc s.pos) c))))

(var skip-non-code (s)
  (while true
    (let c (peek-char s)
      (if (nil? c) (break)
          (get whitespace c) (read-char s)
          (is c ";")
          (do (while (and c (~is c "\n"))
                (assign c (read-char s)))
              (skip-non-code s))
        (break)))))

(var read-table (obj))
(var eof (obj))

(var read (s)
  (skip-non-code s)
  (let c (peek-char s)
    (if (is? c)
	((or (get read-table c)
	     (get read-table ""))
	 s)
      eof)))

(var read-all (s)
  (with l ()
    (while true
      (let form (read s)
        (if (is form eof) (break))
        (add l form)))))

(var read-string (str more)
  (let x (read (stream str more))
    (unless (is x eof) x)))

(var key? (atom)
  (and (string? atom)
       (> (# atom) 1)
       (is (char atom (edge atom)) ":")))

(var flag? (atom)
  (and (string? atom)
       (> (# atom) 1)
       (is (char atom 0) ":")))

(var expected (s c)
  (let ((:more :pos) s)
    (or more (error (cat "Expected " c " at " pos)))))

(var wrap (s x)
  (let y (read s)
    (if (is y s.more) y
      (list x y))))

(var maybe-number (str)
  (when (number-code? (code str (edge str)))
    (number str)))

(var real? (x)
  (and (number? x) (~nan? x) (~inf? x)))

(var valid-access? (str)
  (and (> (# str) 2)
       (~is "." (char str 0))
       (~is "." (char str (edge str)))
       (~search str "..")))

(var parse-access (str)
  (reduce (fn (a b)
            (let n (number a)
              (if (is? n)
                  `(at ,b ,n)
                `(get ,b (quote ,a)))))
          (reverse (split str "."))))

(defreader ("" s) ; atom
  (let (str "" dot? false)
    (while true
      (let c (peek-char s)
	(if (and c (and (~get whitespace c)
			(~get delimiters c)))
	    (do (if (is c ".") (assign dot? true))
                (cat! str (read-char s)))
	  (break))))
  (with atom
    (if (is str "true") true
        (is str "false") false
        (is str "nan") nan
        (is str "-nan") nan
        (is str "inf") inf
        (is str "-inf") -inf
      (let n (maybe-number str)
        (if (real? n) n
            (and dot? (valid-access? str))
            (parse-access str)
          str)))
    (while (is "(" (peek-char s))
      (assign atom `(,atom ,@(read s)))))))

(defreader ("(" s)
  (read-char s)
  (with r nil
    (let l ()
      (while (nil? r)
        (skip-non-code s)
        (let c (peek-char s)
          (if (is c ")") (do (read-char s) (assign r l))
              (nil? c) (assign r (expected s ")"))
            (let x (read s)
              (if (key? x)
                  (let (k (clip x 0 (edge x))
                        v (read s))
                    (assign (get l k) v))
                  (flag? x) (assign (get l (clip x 1)) true)
                (add l x)))))))))

(defreader (")" s)
  (error (cat "Unexpected ) at " s.pos)))

(defreader ("\"" s)
  (read-char s)
  (with r nil
    (let str "\""
      (while (nil? r)
        (let c (peek-char s)
          (if (is c "\"") (assign r (cat str (read-char s)))
              (nil? c) (assign r (expected s "\""))
            (do (when (is c "\\")
                  (cat! str (read-char s)))
                (cat! str (read-char s)))))))))

(defreader ("|" s)
  (read-char s)
  (with r nil
    (let str "|"
      (while (nil? r)
        (let c (peek-char s)
          (if (is c "|") (assign r (cat str (read-char s)))
              (nil? c) (assign r (expected s "|"))
            (cat! str (read-char s))))))))

(defreader ("'" s)
  (read-char s)
  (wrap s 'quote))

(defreader ("`" s)
  (read-char s)
  (wrap s 'quasiquote))

(defreader ("," s)
  (read-char s)
  (if (is (peek-char s) "@")
      (do (read-char s)
	  (wrap s 'unquote-splicing))
    (wrap s 'unquote)))

(export stream
        read
        read-all
        read-string
        read-table)
