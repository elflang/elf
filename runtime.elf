;; -*- mode: lisp -*-

(compile-later

  (define-macro quote (form)
    (quoted form))

  (define-macro quasiquote (form)
    (quasiexpand form 1))

  (define-macro at (l i)
    (if (and (= target 'lua) (number? i))
        (inc i)
        (= target 'lua)
        (set i `(+ ,i 1)))
    `(get ,l ,i))

  (define-macro wipe (place)
    (if (= target 'lua)
        `(set ,place nil)
      `(%delete ,place)))

  (define-macro list body
    (let-unique (x)
      (let (l () forms ())
        (each (k v) body
          (if (number? k)
              (set (get l k) v)
            (add forms `(set (get ,x ',k) ,v))))
        (if (some? forms)
            `(let ,x (%array ,@l) ,@forms ,x)
          `(%array ,@l)))))

  (define-macro if branches
    (hd (expand-if branches)))

  (define-macro case (x rest: clauses)
    (let bs (map (fn ((a b))
                   (if (nil? b)
                       (list a)
                     `((= ,a ,x) ,b)))
                 (pair clauses))
      `(if ,@(apply join bs))))

  (define-macro when (cond rest: body)
    `(if ,cond (do ,@body)))

  (define-macro unless (cond rest: body)
    `(if (not ,cond) (do ,@body)))

  (define-macro obj body
    `(%object ,@(mapo (fn (x) x) body)))

  (define-macro let (bs rest: body)
    (if (atom? bs) `(let (,bs ,(hd body)) ,@(tl body))
        (none? bs) `(do ,@body)
      (let ((lh rh rest: bs2) bs
            (id val rest: bs1) (bind lh rh))
        (let renames ()
          (if (or (bound? id) (toplevel?))
              (let id1 (unique id)
                (set renames (list id id1))
                (set id id1))
            (setenv id :variable))
          `(do (%local ,id ,val)
               (let-symbol ,renames
                 (let ,(join bs1 bs2) ,@body)))))))

  (define-macro with (x v rest: body)
    `(let (,x ,v) ,@body ,x))

  (define-macro let-when (x v rest: body)
    (let-unique (y)
      `(let ,y ,v
         (when ,y
           (let (,x ,y)
             ,@body)))))

  (define-macro define-macro (name args rest: body)
    (let form `(setenv ',name macro: (fn ,args ,@body))
      (eval form)
      form))

  (define-macro define-special (name args rest: body)
    (let form `(setenv ',name special: (fn ,args ,@body) ,@(keys body))
      (eval form)
      form))

  (define-macro define-symbol (name expansion)
    (setenv name symbol: expansion)
    `(setenv ',name symbol: ',expansion))

  (define-macro define-reader ((char s) rest: body)
    `(set (get read-table ,char) (fn (,s) ,@body)))

  (define-macro define (name x rest: body)
    (setenv name :variable)
    (if (some? body)
        `(%local-function ,name ,@(bind* x body))
      `(%local ,name ,x)))

  (define-macro define-global (name x rest: body)
    (setenv name :toplevel :variable)
    (if (some? body)
        `(%global-function ,name ,@(bind* x body))
      `(set ,name ,x)))

  (define-macro with-frame body
    (let-unique (x)
      `(do (add environment (obj))
           (with ,x (do ,@body)
             (drop environment)))))

  (define-macro with-bindings ((names) rest: body)
    (let-unique (x)
     `(with-frame
        (each ,x ,names
          (setenv ,x :variable))
        ,@body)))

  (define-macro let-macro (definitions rest: body)
    (with-frame
      (map (fn (m)
             (macroexpand `(define-macro ,@m)))
           definitions)
      `(do ,@(macroexpand body))))

  (define-macro let-symbol (expansions rest: body)
    (with-frame
      (map (fn ((name exp))
             (macroexpand `(define-symbol ,name ,exp)))
           (pair expansions))
      `(do ,@(macroexpand body))))

  (define-macro let-unique (names rest: body)
    (let bs (map (fn (n)
                   (list n `(unique ',n)))
                 names)
      `(let ,(apply join bs)
         ,@body)))

  (define-macro fn (args rest: body)
    `(%function ,@(bind* args body)))

  (define-macro guard (expr)
    (if (= target 'js)
        `((fn () (%try (list true ,expr))))
      (let-unique (x msg trace)
        `(let (,x nil
               ,msg nil
               ,trace nil)
           (if (xpcall
                (fn () (set ,x ,expr))
                (fn (m)
                  (set ,msg (clip m (+ (search m ": ") 2)))
                  (set ,trace ((get debug 'traceback)))))
               (list true ,x)
             (list false ,msg ,trace))))))

  (define-macro each (x t rest: body)
    (let-unique (o n i)
      (let ((k v) (if (atom? x) (list i x)
                    (if (> (# x) 1) x
                        (list i (hd x)))))
        `(let (,o ,t ,k nil)
           (%for ,o ,k
             (let (,v (get ,o ,k))
               ,@(if (= target 'lua) body
                     `((let ,k (if (numeric? ,k)
                                   (parseInt ,k)
                                 ,k)
                         ,@body)))))))))

  (define-macro for (i to rest: body)
    `(let ,i 0
       (while (< ,i ,to)
         ,@body
         (inc ,i))))

  (define-macro step (v t rest: body)
    (let-unique (x n i)
      `(let (,x ,t ,n (# ,x))
         (for ,i ,n
           (let (,v (at ,x ,i))
             ,@body)))))

  (define-macro set-of xs
    (let l ()
      (each x xs
        (set (get l x) true))
      `(obj ,@l)))

  (define-macro language () `',target)

  (define-macro target clauses
    (get clauses target))

  (define-macro join! (a rest: bs)
    `(set ,a (join ,a ,@bs)))

  (define-macro cat! (a rest: bs)
    `(set ,a (cat ,a ,@bs)))

  (define-macro inc (n by)
    `(set ,n (+ ,n ,(or by 1))))

  (define-macro dec (n by)
    `(set ,n (- ,n ,(or by 1))))

  (define-macro with-indent (form)
    (let-unique (x)
      `(do (inc indent-level)
           (with ,x ,form
             (dec indent-level)))))

  (define-macro export names
    (if (= target 'js)
        `(do ,@(map (fn (k)
                      `(set (get exports ',k) ,k))
                    names))
      (let x (obj)
        (each k names
          (set (get x k) k))
        `(return (obj ,@x)))))

  (define-macro undefined? (var)
    (if (= target 'js)
       `(= (typeof ,var) "undefined")
     `(= ,var nil)))

  (define-macro set-default (var val)
    `(if (undefined? ,var) (set ,var ,val)))

  (define-macro compile-later forms
    (set-default %defer ())
    (eval `(do ,@forms))
    (join! %defer forms)
    nil)

  (define-special finish-compiling ()
    (set-default %defer ())
    (with o ""
      (when (some? %defer)
        (step e %defer
          (cat! o (compile ((get (require 'compiler) 'expand) e) :stmt)))
        (set %defer ()))))

  (define-global reload (module)
    ; temporary hack: node host is trying to require bin/elf instead
    ; of bin/elf.js
    (target js: (if (= module "elf") (cat! module ".js")))
    (target
      js:  (wipe (get (get require 'cache) ((get require 'resolve) module)))
      lua: (wipe (get (get package 'loaded) module)))
    (require module)))

(when (undefined? environment)
  (define-global environment (list (obj)))
  (define-global target (language)))

(define-global nil? (x)
  (target
    js: (or (= x nil) (= x null))
    lua: (= x nil)))

(define-global is? (x) (~nil? x))

(define-global # (x)
  (target js: (or (get x 'length) 0) lua: |#x|))

(define-global none? (x) (= (# x) 0))
(define-global some? (x) (> (# x) 0))
(define-global one? (x) (= (# x) 1))
(define-global two? (x) (= (# x) 2))

(define-global hd (l) (at l 0))

(target js: (define-global type (x) (typeof x)))

(define-global string? (x) (= (type x) 'string))
(define-global number? (x) (= (type x) 'number))
(define-global boolean? (x) (= (type x) 'boolean))
(define-global function? (x) (= (type x) 'function))

(define-global atom? (x)
  (or (nil? x) (string? x) (number? x) (boolean? x)))

(define-global nan (/ 0 0))
(define-global inf (/ 1 0))

(define-global nan? (n)
  (~= n n))

(define-global inf? (n)
  (or (= n inf) (= n -inf)))

(define-global clip (s from upto)
  (target js: ((get s 'substring) from upto)
          lua: ((get string 'sub) s (+ from 1) upto)))

(define-global cut (x from upto)
  (with l ()
    (let (j 0
          i (if (or (nil? from) (< from 0)) 0 from)
          n (# x)
          upto (if (or (nil? upto) (> upto n)) n upto))
      (while (< i upto)
        (set (at l j) (at x i))
        (inc i)
        (inc j))
      (each (k v) x
        (unless (number? k)
          (set (get l k) v))))))

(define-global keys (x)
  (with t ()
    (each (k v) x
      (unless (number? k)
        (set (get t k) v)))))

(define-global edge (x)
  (- (# x) 1))

(define-global inner (x)
  (clip x 1 (edge x)))

(define-global tl (l) (cut l 1))

(define-global char (s n)
  (target js: ((get s 'charAt) n) lua: (clip s n (+ n 1))))

(define-global code (s n)
  (target
    js: ((get s 'charCodeAt) n)
    lua: ((get string 'byte) s (if n (+ n 1)))))

(define-global string-literal? (x)
  (and (string? x) (= (char x 0) "\"")))

(define-global id-literal? (x)
  (and (string? x) (= (char x 0) "|")))

(define-global add (l x)
  (target js: (do ((get l 'push) x) nil)
          lua: ((get table 'insert) l x)))

(define-global drop (l)
  (target js: ((get l 'pop))
          lua: ((get table 'remove) l)))

(define-global last (l)
  (at l (edge l)))

(define-global almost (l)
  (cut l 0 (edge l)))

(define-global reverse (l)
  (with l1 (keys l)
    (let i (edge l)
      (while (>= i 0)
        (add l1 (at l i))
        (dec i)))))

(define-global reduce (f x)
  (if (none? x) nil
      (one? x) (hd x)
    (f (hd x) (reduce f (tl x)))))

(define-global join ls
  (if (two? ls)
      (let ((a b) ls)
        (if (and a b)
            (let (c () o (# a))
              (each (k v) a
                (set (get c k) v))
              (each (k v) b
                (when (number? k)
                  (inc k o))
                (set (get c k) v))
              c)
          (or a b ())))
    (or (reduce join ls) ())))

(define-global find (f t)
  (each x t
    (let y (f x)
      (if y (return y)))))

(define-global first (f l)
  (step x l
    (let y (f x)
      (if y (return y)))))

(define-global in? (x t)
  (find (fn (y) (= x y)) t))

(define-global pair (l)
  (with l1 ()
    (for i (# l)
      (add l1 (list (at l i) (at l (+ i 1))))
      (inc i))))

(define-global sort (l f)
  (target
    lua: (do ((get table 'sort) l f) l)
    js: ((get l 'sort) (when f (fn (a b) (if (f a b) -1 1))))))

(define-global map (f x)
  (with t ()
    (step v x
      (let y (f v)
        (if (is? y)
          (add t y))))
    (each (k v) x
      (unless (number? k)
        (let y (f v)
          (when (is? y)
            (set (get t k) y)))))))

(define-global keep (f x)
  (map (fn (v) (when (f v) v)) x))

(define-global keys? (t)
  (each (k v) t
    (unless (number? k)
      (return true)))
  false)

(define-global empty? (t)
  (each x t
    (return false))
  true)

(define-global stash (args)
  (when (keys? args)
    (let p ()
      (each (k v) args
        (unless (number? k)
          (set (get p k) v)))
      (set (get p '_stash) true)
      (add args p)))
  args)

(define-global unstash (args)
  (if (none? args) ()
    (let l (last args)
      (if (and (~atom? l) (~function? l) (get l '_stash))
          (with args1 (almost args)
            (each (k v) l
              (unless (= k '_stash)
                (set (get args1 k) v))))
        args))))

(define-global search (s pattern start)
  (target
    js: (let i ((get s 'indexOf) pattern start)
          (if (>= i 0) i))
    lua: (let (start (if start (+ start 1))
               i ((get string 'find) s pattern start true))
           (and i (- i 1)))))

(define-global split (s sep)
  (if (or (= s "") (= sep "")) ()
    (with l ()
      (let n (# sep)
        (while true
          (let i (search s sep)
            (if (nil? i) (break)
              (do (add l (clip s 0 i))
                  (set s (clip s (+ i n)))))))
        (add l s)))))

(define-global cat xs
  (or (reduce (fn (a b) (cat a b)) xs) ""))

(define-global + xs
  (or (reduce (fn (a b) (+ a b)) xs) 0))

(define-global - xs
  (or (reduce (fn (b a) (- a b)) (reverse xs)) 0))

(define-global * xs
  (or (reduce (fn (a b) (* a b)) xs) 1))

(define-global / xs
  (or (reduce (fn (b a) (/ a b)) (reverse xs)) 1))

(define-global % xs
  (or (reduce (fn (b a) (% a b)) (reverse xs)) 0))

(define-global > (a b) (> a b))
(define-global < (a b) (< a b))
(define-global = (a b) (= a b))
(define-global >= (a b) (>= a b))
(define-global <= (a b) (<= a b))

(define-global number (s)
  (target
    js: (let n (parseFloat s)
          (unless (isNaN n) n))
    lua: (tonumber s)))

(define-global number-code? (n)
  (and (> n 47) (< n 58)))

(define-global numeric? (s)
  (let n (# s)
    (for i n
      (unless (number-code? (code s i))
        (return false))))
  true)

(target js: (define tostring (x) ((get x 'toString))))

(define-global escape (s)
  (let s1 "\""
    (for i (# s)
      (let (c (char s i)
            c1 (if (= c "\n") "\\n"
                   (= c "\"") "\\\""
                   (= c "\\") "\\\\"
                 c))
        (cat! s1 c1)))
    (cat s1 "\"")))

(define-global str (x depth)
  (if (and depth (> depth 40)) "circular"
      (nil? x) "nil"
      (nan? x) "nan"
      (= x inf) "inf"
      (= x -inf) "-inf"
      (boolean? x) (if x "true" "false")
      (string? x) (escape x)
      (atom? x) (tostring x)
      (function? x) "fn"
    (let (s "(" sp ""
          xs () ks ()
          d (+ (or depth 0) 1))
      (each (k v) x
        (if (number? k)
            (set (get xs k) (str v d))
          (do (add ks (cat k ":"))
              (add ks (str v d)))))
      (each v (join xs ks)
        (cat! s sp v)
        (set sp " "))
      (cat s  ")"))))

(target lua:
  (define values (or unpack (get table 'unpack))))

(define-global apply (f args)
  (let args (stash args)
    (target js: ((get f 'apply) f args)
            lua: (f (values args)))))

(define-global call (f) (f))

(define-global toplevel? ()
  (one? environment))

(define-global setenv (k rest: keys)
  (when (string? k)
    (let (frame (if (get keys 'toplevel)
                    (hd environment)
                  (last environment))
          entry (or (get frame k) (obj)))
      (each (k v) keys
        (set (get entry k) v))
      (set (get frame k) entry))))

(target js:
  (define-global print (x)
    ((get console 'log) x)))

(define math (target js: Math lua: math))

(define-global abs (get math 'abs))
(define-global acos (get math 'acos))
(define-global asin (get math 'asin))
(define-global atan (get math 'atan))
(define-global atan2 (get math 'atan2))
(define-global ceil (get math 'ceil))
(define-global cos (get math 'cos))
(define-global floor (get math 'floor))
(define-global log (get math 'log))
(define-global log10 (get math 'log10))
(define-global max (get math 'max))
(define-global min (get math 'min))
(define-global pow (get math 'pow))
(define-global random (get math 'random))
(define-global sin (get math 'sin))
(define-global sinh (get math 'sinh))
(define-global sqrt (get math 'sqrt))
(define-global tan (get math 'tan))
(define-global tanh (get math 'tanh))

(finish-compiling)
